@page "/snake"
@rendermode InteractiveServer
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Numerics
@using System.Diagnostics
@using System.Text.Json
@using CS3500.Networking
@using GUI.Client.Controllers;
@using GUI.Client.Models;
@inject IJSRuntime JsRuntime;

<PageTitle> Snake </PageTitle>
<img @ref="backgroundImage" id="bgImage" src="images/Background.png" alt="image" style="display:none;" />
<img @ref="SpaceImage" id="sImage" src="images/Space Background.jpg" alt="image" style="display:none;" />
<img @ref="ForestImage" id="fImage" src="images/Forest Floor Background.jpg" alt="image" style="display:none;" />
<img @ref="DesertImage" id="dImage" src="images/Desert Background.jpg" alt="image" style="display:none;" />
<img @ref="wallImage" id="wImage" src="images/WallSprite.png" alt="image" style="display:none;" />

<div class="input-row">
	<label for="url"> Server Address: </label>
	<input id="url" disabled="@network.IsConnected" type="text" @bind="ServerNameOrAddress" />
	<label for="url"> Port: </label>
	<input id="port" disabled="@network.IsConnected" type="number" @bind="ServerPort" class="port" />
	<label for="url"> Name: </label>
	<input form="name" disabled="@network.IsConnected" type="text" @bind="UserName" />
	@if (network.IsConnected)
	{
		<button class="btn btn-primary" @onclick="DisconnectFromServer">Disconnect</button>
	}
	else
	{
		<button class="btn btn-primary" @onclick="ConnectToServer">Connect</button>
	}
</div>

<button class="btn btn-primary" @onclick="ConnectToServer">Desert</button>
<button class="btn btn-primary" @onclick="ConnectToServer">Forest</button>
<button class="btn btn-primary" @onclick="ConnectToServer">Space</button>

<div id="snakeCanvas" style="position: fixed; width: 100%; height: 100%">
	<BECanvas Width="1000" Height="1000" @ref="canvasReference"></BECanvas>
</div>

@code
{
	public SnakeGUI()
	{
		//Do we even put anything in here?
	}

	/// <summary>
	/// Default server name
	/// </summary>
	private string ServerNameOrAddress = "localhost";

	/// <summary>
	/// Default server port
	/// </summary>
	private int ServerPort = 11000;

	/// <summary>
	/// The NetworkController object representing a connection with the server
	/// </summary>
	private NetworkController network = new();

	/// <summary>
	/// The name taken from the input box;
	/// </summary>
	private string UserName = "";

	private Point2D head = new Point2D(1000, 1000);
	private Point2D tail = new Point2D(1000, 1000);

	private const int WorldSize = 1000;
	//This may cause problems - review
	public static World TheWorld = new();
	private BECanvasComponent canvasReference = null!;
	private Canvas2DContext context = null!;
	private IJSObjectReference jsModule = null!;
	private ElementReference backgroundImage;
	private ElementReference DesertImage;
	private ElementReference ForestImage;
	private ElementReference SpaceImage;
	private ElementReference wallImage;
	private ElementReference ImageSelection;
	private const int ViewWidth = 1000;
	private const int ViewHeight = 1000;

	/// <summary>
	///
	/// </summary>
	/// <param name="firstRender"></param>
	/// <returns></returns>
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/SnakeGUI.razor.js");
			context = await canvasReference.CreateCanvas2DAsync();
			await JsRuntime.InvokeAsync<object>("initRenderJS", DotNetObjectReference.Create(this));

			GameLoop();
		}
	}

	/// <summary>
	///     Renders the view once every 20 milliseconds.
	/// </summary>
	private async void GameLoop()
	{
		while (true)
		{
			Thread.Sleep(20);
			await DrawFrame();
		}
	}

	/// <summary>
	///     Draws all the items in the game including the background, walls, powerups, and snakes.
	///     Draws one frame of the game.
	/// </summary>
	/// <returns></returns>
	private async Task DrawFrame()
	{
		World copyWorld;
		lock(TheWorld) {
			copyWorld = new(TheWorld);
		}

		await context.BeginBatchAsync();

		// clip the view so that objects drawn outside the canvas will not be shown
		await context.BeginPathAsync();
		await context.RectAsync(0, 0, ViewWidth, ViewHeight);
		await context.ClipAsync();

		// // Because we are modifying the transformation matrix, we need to save it so we can restore it at the end
		await context.SaveAsync();

		//Center on origin, move to center of view port
		await context.TranslateAsync( ViewWidth / 2, ViewHeight / 2);
		//await context.TranslateAsync(-head.x, -head.y);

		// Draw the background:
		await context.DrawImageAsync(ImageSelection, -copyWorld.Width / 2, -copyWorld.Height / 2, copyWorld.Width, copyWorld.Height);


		// Something that draws all the walls and powerups as the world gets made.
		foreach (Snake snake in copyWorld.snakes.Values)
		{
			//Prep to draw a snake
			await context.SetLineWidthAsync(10);

			//Select a color that hasn't been chosen before (unless there are more than 8 players)
			await context.SetStrokeStyleAsync(network.setSnakeColor(network.colors).ToString()); // Might have to change if this does not work.

			//Draw a snake
			await context.SetLineCapAsync(LineCap.Round);
			await context.BeginPathAsync();
			//Starting location of the snake/line (tail)
			await context.MoveToAsync(50,100);
			//Ending location of the snake/line (head)
			await context.LineToAsync(150, 200);
			await context.StrokeAsync();
		}

		foreach (Powerup p in copyWorld.powerups.Values)
		{
			//smaller yellow circle for powerups
			await context.SetLineWidthAsync(5);
			await context.SetLineCapAsync(LineCap.Round);
			await context.SetStrokeStyleAsync($"rgb( 255, 255, 0 )");
			await context.BeginPathAsync();
			await context.ArcAsync(p.loc.X, p.loc.Y, 3, 0, 2 * Math.PI);
			await context.StrokeAsync();
		}

		// 	Have two walls: one vertical and one horizontal
		foreach (ObstacleWall wall in copyWorld.walls.Values) 
		{
			// for vertical walls the x points will be the same
			if (wall.p1.X == wall.p2.X) 
			{
				if(wall.p1.Y < wall.p2.Y)
				{
					for (int i = wall.p1.Y; i <= wall.p2.Y; i += 50)
					{
						await context.DrawImageAsync(wallImage, wall.p1.X - 25, i - 25, 50, 50);
					}
				}
				else
				{
					for(int i = wall.p2.Y; i <= wall.p1.Y; i += 50)
					{
						await context.DrawImageAsync(wallImage, wall.p1.X - 25, i - 25, 50, 50);
					}
				}
			}
			// for horizional walls the y points will be the same
			if (wall.p1.Y == wall.p2.Y)
			{
				if(wall.p1.X < wall.p2.X)
				{
					for (int i = wall.p1.X; i <= wall.p2.X; i += 50)
					{
						await context.DrawImageAsync(wallImage, i - 25, wall.p1.Y - 25, 50, 50);
					}
				}
				else
				{
					for (int i = wall.p2.X; i <= wall.p1.X; i += 50)
					{
						await context.DrawImageAsync(wallImage, i - 25, wall.p1.Y - 25, 50, 50);
					}
				}
			}
		}

		await context.RestoreAsync();
		// finish batch drawing
		await context.EndBatchAsync();

		StateHasChanged();
	}

	/// <summary>
	/// Handler for the connect button
	/// Attempt to connect to the server, then start an asynchronous loop
	/// to receive and display messages.
	/// Called only when you click the connect button.
	/// </summary>
	private void ConnectToServer()
	{
		new Thread(() => network.HandleConnect(UserName, TheWorld)).Start();
	}

	/// <summary>
	///     Disconnects the user from the server.
	/// </summary>
	private void DisconnectFromServer()
	{
		network.DisconnectServer();
	}

	/// <summary>
	///     When the user presses a specific key on the keyboard, the snake on the screen
	///     asks the server to move.
	/// </summary>
	/// <param name="key"></param>
	[JSInvokable]
	public void HandleKeyPress(string key)
	{
		if (network.IsConnected)
		{
			key = key.ToLower();
			// TODO: Once the client is connected and the handshake is complete,
			//       invoke some controller method to send the appropriate command to the server
			if (key.Equals("w")) /*Keep track of the axis*/
			{
				network.moveUP();
			}
			else if (key.Equals("a")) /*Keep track of the axis*/
			{
				network.moveLEFT();
			}
			else if (key.Equals("s")) /*Keep track of the axis*/
			{
				network.moveRIGHT();
			}
			else if (key.Equals("d")) /*Keep track of the axis*/
			{
				network.moveDOWN();
			}

			// TODO: Remove this, which is just here to show you what the 'key' string is for whatever key you pressed
			Debug.WriteLine("key pressed: " + key);
		}
	}

	private void setDesertBackground()
	{
		ImageSelection = DesertImage;
	}

	private void setForestBackground()
	{
		ImageSelection = ForestImage;
	}

	private void setSpaceBackground()
	{
		ImageSelection = SpaceImage;
	}
}

