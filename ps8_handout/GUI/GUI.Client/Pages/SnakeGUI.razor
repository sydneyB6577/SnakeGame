@page "/snake"
@rendermode InteractiveServer
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Numerics
@using System.Diagnostics
@using System.Text.Json
@using CS3500.Networking
@using GUI.Client.Controllers;
@using GUI.Client.Models;
@using System.Drawing;
@inject IJSRuntime JsRuntime;

@*
	This class keeps track of the GUI elements of the snake game. It also starts the game
	and starts the connection. 

	Authors: Sydney Burt and Levi Hammond
	Date: April 11, 2025
*@

@*Title of the snake game. Also creates image references for all images used during the game.*@
<PageTitle> Snake </PageTitle>
<img @ref="backgroundImage" id="bgImage" src="images/Background.png" alt="image" style="display:none;" />
<img @ref="SpaceImage" id="sImage" src="images/Space Background.jpg" alt="image" style="display:none;" />
<img @ref="ForestImage" id="fImage" src="images/Forest Floor Background.jpg" alt="image" style="display:none;" />
<img @ref="DesertImage" id="dImage" src="images/Desert Background.jpg" alt="image" style="display:none;" />
<img @ref="wallImage" id="wImage" src="images/WallSprite.png" alt="image" style="display:none;" />

@*Text boxes and buttons to connect to the server, disconnect from the server, and enter a name.*@
<div class="input-row">
	<label for="url"> Server Address: </label>
	<input id="url" disabled="@network.IsConnected" type="text" @bind="ServerNameOrAddress" />
	<label for="url"> Port: </label>
	<input id="port" disabled="@network.IsConnected" type="number" @bind="ServerPort" class="port" />
	<label for="url"> Name: </label>
	<input form="name" disabled="@network.IsConnected" type="text" @bind="UserName" />
	@if (network.IsConnected)
	{
		<button class="btn btn-primary" @onclick="DisconnectFromServer">Disconnect</button>
	}
	else
	{
		<button class="btn btn-primary" @onclick="ConnectToServer">Connect</button>
	}
</div>

@*Buttons for the 3 new backgrounds.*@
<button class="btn btn-primary" @onclick="setBackground1">Desert</button>
<button class="btn btn-primary" @onclick="setBackground2">Forest</button> 
<button class="btn btn-primary" @onclick="setBackground3">Space</button>

@*The snake canvas the game will take place on.*@
<div id="snakeCanvas" style="position: fixed; width: 100%; height: 100%">
	<BECanvas Width="1000" Height="1000" @ref="canvasReference"></BECanvas>*
</div>

@code
{
	/// <summary>
	///		An empty SnakeGUI constructor that takes no parameters.
	/// </summary>
	public SnakeGUI()
	{
	}

	/// <summary>
	///		The default server name.
	/// </summary>
	private string ServerNameOrAddress = "localhost";

	/// <summary>
	///		The default server port number.
	/// </summary>
	private int ServerPort = 11000;

	/// <summary>
	///		The NetworkController object representing a connection with the server.
	/// </summary>
	private NetworkController network = new();

	/// <summary>
	///		The name taken from the input box.
	/// </summary>
	private string UserName = "";

	//Variables to instantiate the world.
	public World TheWorld = new();

	//Components to draw the GUI.
	private BECanvasComponent canvasReference = null!;
	private Canvas2DContext context = null!;
	private IJSObjectReference jsModule = null!;

	//ElementReferences for all the images used.
	private ElementReference backgroundImage;
	private ElementReference DesertImage;
	private ElementReference ForestImage;
	private ElementReference SpaceImage; 
	private ElementReference wallImage;

	//Width and height of the user's view.
	private const int ViewWidth = 1000;
	private const int ViewHeight = 1000;

	//Variable to control the background image selection.
	private int background = 0;

	/// <summary>
	///		Called after the page is rendered. This is used to know when the first page load
	///		has occurred so the program can initialize various data and start the server and drawing loops.
	/// </summary>
	/// <param name="firstRender"></param>
	/// <returns></returns>
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/SnakeGUI.razor.js");
			context = await canvasReference.CreateCanvas2DAsync();
			await JsRuntime.InvokeAsync<object>("initRenderJS", DotNetObjectReference.Create(this));

			GameLoop();
		}
	}

	/// <summary>
	///     Renders the view once every 20 milliseconds.
	/// </summary>
	private async void GameLoop()
	{
		while (true)
		{
			Thread.Sleep(20);
			await DrawFrame();
		}
	}

	/// <summary>
	///     Draws all the items in the game including the background, walls, powerups, and snakes.
	///     Draws one frame of the game.
	/// </summary>
	/// <returns></returns>
	private async Task DrawFrame()
	{
		//Makes a copy of the world so that the game can run without race conditions.
		World copyWorld;
		lock(TheWorld) {
			copyWorld = new(TheWorld);
		}

		if (!copyWorld.snakes.ContainsKey(copyWorld.currentPlayerID))
		{
			await context.BeginBatchAsync();
			await context.EndBatchAsync();
			return;
		}

		await context.BeginBatchAsync();

		//Draws the game background outside the arena.
		await context.FillRectAsync(0, 0, 1000, 1000);
		await context.SetFillStyleAsync("lightblue");


		//Clip the view so that objects drawn outside the canvas will not be shown.
		await context.BeginPathAsync();
		await context.RectAsync(0, 0, ViewWidth, ViewHeight);
		await context.ClipAsync();

		//Because the code is modifying the transformation matrix, it needs to be save so it can be restored at the end.
		await context.SaveAsync();

		//Center on origin, move to center of view port.
		await context.TranslateAsync( ViewWidth / 2, ViewHeight / 2);
		await context.TranslateAsync(-copyWorld.getPlayerHead().X, -copyWorld.getPlayerHead().Y);

		//Draw the background based on which button is pushed.
		if(background == 1)
		{
			await context.DrawImageAsync(DesertImage, -copyWorld.Width / 2, -copyWorld.Height / 2, copyWorld.Width, copyWorld.Height);
		}
		else if (background == 2)
		{
			await context.DrawImageAsync(ForestImage, -copyWorld.Width / 2, -copyWorld.Height / 2, copyWorld.Width, copyWorld.Height);
		}
		else if (background == 3)
		{
			await context.DrawImageAsync(SpaceImage, -copyWorld.Width / 2, -copyWorld.Height / 2, copyWorld.Width, copyWorld.Height);
		}
		else
		{
			await context.DrawImageAsync(backgroundImage, -copyWorld.Width / 2, -copyWorld.Height / 2, copyWorld.Width, copyWorld.Height);
		}

		//Draws each snake in the arena.
		foreach (Snake snake in copyWorld.snakes.Values)
		{
			//Prep to draw a snake.
			await context.SetLineWidthAsync(10);

			//Select a color that hasn't been chosen before.
			await context.SetStrokeStyleAsync(snake.color);

			//Draw code loop for each point in the snake body; move to the tail first.
			await context.SetLineCapAsync(LineCap.Round);
			await context.SetLineWidthAsync(10);
			await context.SetLineJoinAsync(LineJoin.Round);
			await context.BeginPathAsync();
			await context.MoveToAsync(snake.body[0].X, snake.body[0].Y);
			for (int i = 0; i < snake.body.Count; i += 1) 
			{
				await context.LineToAsync(snake.body[i].X, snake.body[i].Y);
				await context.FillTextAsync("name: " + snake.name + " score: " + snake.score.ToString(), snake.body[snake.body.Count - 1].X + 20, snake.body[snake.body.Count - 1].Y + 20, 200);
			}
			await context.StrokeAsync();
		}

		//Draws all the walls and powerups as the world gets made.
		foreach (Powerup p in copyWorld.powerups.Values)
		{
			//Draws a smaller yellow circle for powerups.
			if (!p.died)
			{
				await context.SetLineWidthAsync(16);
				await context.SetLineCapAsync(LineCap.Round);
				await context.SetStrokeStyleAsync($"rgb( 255, 255, 0 )");
				await context.BeginPathAsync();
				await context.ArcAsync(p.loc.X, p.loc.Y, 3, 0, 2 * Math.PI);
				await context.StrokeAsync();
			}
		}

		//Have two walls: one vertical and one horizontal.
		foreach (ObstacleWall wall in copyWorld.walls.Values) 
		{
			//For vertical walls, the x points will be the same.
			if (wall.p1.X == wall.p2.X) 
			{
				if(wall.p1.Y < wall.p2.Y)
				{
					for (int i = wall.p1.Y; i <= wall.p2.Y; i += 50)
					{
						await context.DrawImageAsync(wallImage, wall.p1.X - 25, i - 25, 50, 50);
					}
				}
				else
				{
					for(int i = wall.p2.Y; i <= wall.p1.Y; i += 50)
					{
						await context.DrawImageAsync(wallImage, wall.p1.X - 25, i - 25, 50, 50);
					}
				}
			}
			//For horizional walls, the y points will be the same.
			if (wall.p1.Y == wall.p2.Y)
			{
				if(wall.p1.X < wall.p2.X)
				{
					for (int i = wall.p1.X; i <= wall.p2.X; i += 50)
					{
						await context.DrawImageAsync(wallImage, i - 25, wall.p1.Y - 25, 50, 50);
					}
				}
				else
				{
					for (int i = wall.p2.X; i <= wall.p1.X; i += 50)
					{
						await context.DrawImageAsync(wallImage, i - 25, wall.p1.Y - 25, 50, 50);
					}
				}
			}
		}
		await context.RestoreAsync();

		// finish batch drawing
		await context.EndBatchAsync();

		StateHasChanged();
	}

	/// <summary>
	///		Handler for the connect button
	///		Attempt to connect to the server, then start an asynchronous loop
	///		to receive and send messages.
	///		Called only when the user clicks the connect button.
	/// </summary>
	private void ConnectToServer()
	{
		new Thread(() => network.HandleConnect(UserName, TheWorld)).Start();
	}

	/// <summary>
	///     Handler for the disconnect button
	///		Disconnects the user from the server.
	///		Called only when the user clicks the connect button while already connected.
	/// </summary>
	private void DisconnectFromServer()
	{
		network.DisconnectServer();
	}

	/// <summary>
	///     When the user presses a specific key on the keyboard, the snake on the screen
	///     asks the server to move.
	/// </summary>
	/// <param name="key">The key the user presses to ptentially move the snake.</param>
	[JSInvokable]
	public void HandleKeyPress(string key)
	{
		if (network.IsConnected)
		{
			//Makes the awsd keys always lowercase, so they can be used even in caps lock.
			key = key.ToLower();

			if (key.Equals("w")) 
			{
				network.moveUP();
			}
			else if (key.Equals("a")) 
			{
				network.moveLEFT();
			}
			else if (key.Equals("s")) 
			{
				network.moveDOWN();
			}
			else if (key.Equals("d")) 
			{
				network.moveRIGHT();
			}
		}
	}

	/// <summary>
	///		This class sets the desert background when the Desert button is clicked.
	/// </summary>
	private void setBackground1()
	{
		background = 1;
	}

	/// <summary>
	///		This class sets the forest background when the Forest button is clicked.
	/// </summary>
	private void setBackground2()
	{
		background = 2;
	}

	/// <summary>
	///		This class sets the space background when the space button is clicked.
	/// </summary>
	private void setBackground3()
	{
		background = 3;
	}
}

