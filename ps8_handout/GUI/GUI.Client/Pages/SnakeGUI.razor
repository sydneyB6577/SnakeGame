@page "/snake"
@rendermode InteractiveServer
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Numerics
@using System.Diagnostics
@using System.Text.Json
@using CS3500.Networking
@using GUI.Client.Controllers;
@using GUI.Client.Models;
@inject IJSRuntime JsRuntime;

<PageTitle> Snake </PageTitle>

<div id="snakeCanvas" style="position: fixed; width: 100%; height: 100%">
    <BECanvas Width="1000" Height="1000" @ref="canvasReference"></BECanvas>
    <div class="input-row">
        <label for="url"> Server Address: </label>
        <input id="url" disabled="@network.IsConnected" type="text" @bind="ServerNameOrAddress" />
        <label for="url"> Port: </label>
        <input id="port" disabled="@network.IsConnected" type="number" @bind="ServerPort" class="port" />
        <label for="url"> Name: </label>
        <input form="name" disabled="@network.IsConnected" type="text" @bind="UserName" />
        @if (network.IsConnected)
        {
            <button class="btn btn-primary" @onclick="DisconnectFromServer">Disconnect</button>
        }
        else
        {
            <button class="btn btn-primary" @onclick="ConnectToServer">Connect</button>
        }
    </div>
</div>
<div class=music-adjustable>
    <button class="btn btn-primary" onclick="">Music</button> @* Change this to just be a volume bar*@
</div>

<audio id="player">
    <source id="playerSource" src="" />
</audio>

@code
{
    public SnakeGUI()
    {
        //Do we even put anything in here?
    }

    /// <summary>
    /// Default server name
    /// </summary>
    private string ServerNameOrAddress = "localhost";

    /// <summary>
    /// Default server port
    /// </summary>
    private int ServerPort = 11000;

    /// <summary>
    /// The NetworkController object representing a connection with the server
    /// </summary>
    private NetworkController network = new();

    /// <summary>
    /// The name taken from the input box;
    /// </summary>
    private string UserName = "steve";

    /// <summary>
    ///     The first point object in a Snake's body list.
    /// </summary>
    private Point2D? head;

    private const int WorldSize = 1000;
    //This may cause problems - review
    public static World TheWorld = new();
    private BECanvasComponent canvasReference = null!;
    private Canvas2DContext context = null!;
    private IJSObjectReference jsModule = null!;
    private ElementReference backgroundImage;
    private const int ViewWidth = 1000;
    private const int ViewHeight = 1000;

    /// <summary>
    /// 
    /// </summary>
    /// <param name="firstRender"></param>
    /// <returns></returns>
    protected override async Task OnAfterRenderAsync( bool firstRender )
    {
        if ( firstRender )
        {
            jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>( "import", "./Pages/SnakeGUI.razor.js" );
            context = await canvasReference.CreateCanvas2DAsync();
            await JsRuntime.InvokeAsync<object>( "initRenderJS", DotNetObjectReference.Create( this ) );

            GameLoop();
        }
    }

    /// <summary>
    ///     Renders the view once every 20 milliseconds. 
    /// </summary>
    private async void GameLoop() 
    {
        while(true) 
        {
            Thread.Sleep(20);
            await DrawFrame();
        }
    }

    /// <summary>
    ///     Draws all the items in the game including the background, walls, powerups, and snakes.
    ///     Draws one frame of the game.
    /// </summary>
    /// <returns></returns>
    private async Task DrawFrame()
    {
        await context.BeginBatchAsync();

        // clip the view so that objects drawn outside the canvas will not be shown
        await context.BeginPathAsync();
        await context.RectAsync(0, 0, ViewWidth, ViewHeight);
        await context.ClipAsync();

        // Because we are modifying the transformation matrix, we need to save it so we can restore it at the end
        await context.SaveAsync();

        // Center on origin, move to center of view port
        await context.TranslateAsync(ViewWidth / 2, ViewHeight / 2);
        await context.TranslateAsync(-head!.x, -head.y);

        // Draw the background:
        await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);


        // Something that draws all the walls and powerups as the world gets made.


        foreach (Snake p in TheWorld.snakes.Values)
        {
            //Prep to draw a snake
            await context.SetLineWidthAsync(5);

            //Select a color that hasn't been chosen before (rn its red)

            await context.SetStrokeStyleAsync($"rgb( 255, 0, 0 )");

            //Draw a snake
            await context.SetLineCapAsync(LineCap.Round);
            await context.BeginPathAsync();
            //Starting location of the snake/line (tail)
            await context.MoveToAsync(50, 50);
            //Ending location of the snake/line (head)
            await context.LineToAsync(100, 50);
            await context.StrokeAsync();
        }

        foreach (Powerup p in TheWorld.powerups.Values) //Bug
        {
            // smaller yellow circle for powerups
            await context.SetLineWidthAsync(5);
            await context.SetStrokeStyleAsync($"rgb( 255, 255, 0 )");
            await context.BeginPathAsync();
            await context.ArcAsync(p.loc.x, p.loc.y, 3, 0, 2 * Math.PI);
            await context.StrokeAsync();
        }

        //Might not need the for-each loop because I dont need to make the walls several times.
        foreach (ObstacleWall wall in TheWorld.walls.Values)
        {
            //Have two walls: one vertical and one horizontal

            //Draw walls surrounding the world
            //Vertical Left
            await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
            //Vertical Right
            await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
            //Horizontal Top
            await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
            //Horizontal Bottom
            await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);

            //Draw ___ (6? 10?) randomly placed and rotated walls in the world
            for(int i = 0; i < 3; i++)
            {
                //Draw one vertical wall in a random spot
                await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
                //Draw one horizontal wall in a random spot
                await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
            }
        }

        // finish batch drawing
        await context.EndBatchAsync();

        StateHasChanged();
    }

    /// <summary>
    /// Handler for the connect button
    /// Attempt to connect to the server, then start an asynchronous loop
    /// to receive and display messages.
    /// Called only when you click the connect button.
    /// </summary>
    private void ConnectToServer()
    {
        new Thread(() => network.HandleConnect(UserName)).Start();
    }

    /// <summary>
    ///     Disconnects the user from the server.
    /// </summary>
    private void DisconnectFromServer()
    {
        network.DisconnectServer();
    }

    /// <summary>
    ///     When the user presses a specific key on the keyboard, the snake on the screen
    ///     asks the server to move. 
    /// </summary>
    /// <param name="key"></param>
    [JSInvokable]
    public void HandleKeyPress( string key )
    {
        key = key.ToLower();
        // TODO: Once the client is connected and the handshake is complete,
        //       invoke some controller method to send the appropriate command to the server
        if (key.Equals("w")) /*Keep track of the axis*/
        {
            network.moveUP();
        }
        else if (key.Equals("a")) /*Keep track of the axis*/
        {
            network.moveLEFT();
        }
        else if (key.Equals("s")) /*Keep track of the axis*/
        {
            network.moveRIGHT();
        }
        else if (key.Equals("d")) /*Keep track of the axis*/
        {ter,
            network.moveDOWN();
        }

        // TODO: Remove this, which is just here to show you what the 'key' string is for whatever key you pressed
        Debug.WriteLine("key pressed: " + key);
    }
}

