@page "/snake"
@rendermode InteractiveServer
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Numerics
@using System.Diagnostics
@using System.Text.Json
@using CS3500.Networking
@using GUI.Client.Controllers;
@using GUI.Client.Models;
@inject IJSRuntime JsRuntime;

<PageTitle> Snake </PageTitle>
<img @ref="backgroundImage" id="bgImage" src="images/Background.png" alt="image" style="display:none;" />
<img @ref="SpaceImage" id="sImage" src="images/Space Background.jpg" alt="image" style="display:none;" />
<img @ref="ForestImage" id="fImage" src="images/Forest Floor Background.jpg" alt="image" style="display:none;" />
<img @ref="DesertImage" id="dImage" src="images/Desert Background.jpg" alt="image" style="display:none;" />
<img @ref="wallImage" id="wImage" src="images/WallSprite.png" alt="image" style="display:none;" />

<div class="input-row">
	<label for="url"> Server Address: </label>
	<input id="url" disabled="@network.IsConnected" type="text" @bind="ServerNameOrAddress" />
	<label for="url"> Port: </label>
	<input id="port" disabled="@network.IsConnected" type="number" @bind="ServerPort" class="port" />
	<label for="url"> Name: </label>
	<input form="name" disabled="@network.IsConnected" type="text" @bind="UserName" />
	@if (network.IsConnected)
	{
		<button class="btn btn-primary" @onclick="DisconnectFromServer">Disconnect</button>
	}
	else
	{
		<button class="btn btn-primary" @onclick="ConnectToServer">Connect</button>
	}
</div>

<div id="snakeCanvas" style="position: fixed; width: 100%; height: 100%">
	<BECanvas Width="1000" Height="1000" @ref="canvasReference"></BECanvas>
</div>

<div class=music-adjustable>
	@* <button class="btn btn-primary" @onclick="ConnectToServer">Music</button> @* Change this to just be a volume bar*@
</div>


<audio id="player">
	<source id="playerSource" src="" />
</audio>

@code
{
	public SnakeGUI()
	{
		//Do we even put anything in here?
	}

	/// <summary>
	/// Default server name
	/// </summary>
	private string ServerNameOrAddress = "localhost";

	/// <summary>
	/// Default server port
	/// </summary>
	private int ServerPort = 11000;

	/// <summary>
	/// The NetworkController object representing a connection with the server
	/// </summary>
	private NetworkController network = new();

	/// <summary>
	/// The name taken from the input box;
	/// </summary>
	private string UserName = "";

	private const int WorldSize = 1000;
	//This may cause problems - review
	public static World TheWorld = new();
	private BECanvasComponent canvasReference = null!;
	private Canvas2DContext context = null!;
	private IJSObjectReference jsModule = null!;
	private ElementReference backgroundImage;
	private ElementReference DesertImage;
	private ElementReference ForestImage;
	private ElementReference SpaceImage;
	private ElementReference wallImage;
	private const int ViewWidth = 1000;
	private const int ViewHeight = 1000;

	/// <summary>
	///
	/// </summary>
	/// <param name="firstRender"></param>
	/// <returns></returns>
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/SnakeGUI.razor.js");
			context = await canvasReference.CreateCanvas2DAsync();
			await JsRuntime.InvokeAsync<object>("initRenderJS", DotNetObjectReference.Create(this));

			GameLoop();
		}
	}

	/// <summary>
	///     Renders the view once every 20 milliseconds.
	/// </summary>
	private async void GameLoop()
	{
		while (true)
		{
			Thread.Sleep(20);
			await DrawFrame();
		}
	}

	/// <summary>
	///     Draws all the items in the game including the background, walls, powerups, and snakes.
	///     Draws one frame of the game.
	/// </summary>
	/// <returns></returns>
	private async Task DrawFrame()
	{
		World copyWorld;
		lock(TheWorld) {
			copyWorld = new(TheWorld);
		}
		await context.BeginBatchAsync();

		// clip the view so that objects drawn outside the canvas will not be shown
		await context.BeginPathAsync();
		await context.RectAsync(0, 0, ViewWidth, ViewHeight);
		await context.ClipAsync();

		// // Because we are modifying the transformation matrix, we need to save it so we can restore it at the end
		await context.SaveAsync();

		//Center on origin, move to center of view port
		await context.TranslateAsync(ViewWidth / 2, ViewHeight / 2);
		//await context.TranslateAsync(-head!.x, -head.y);

		// Draw the background:
		await context.DrawImageAsync(backgroundImage, -copyWorld.Size, 0, ViewWidth, ViewHeight);


		// Something that draws all the walls and powerups as the world gets made.


		// foreach (Snake p in TheWorld.snakes.Values)
		// {
		// 	Prep to draw a snake
		// 	await context.SetLineWidthAsync(5);

		// 	Select a color that hasn't been chosen before (rn its red)

		// 	await context.SetStrokeStyleAsync(network.setSnakeColor(network.colors)); Might have to change if this does not work.

		// 	Draw a snake
		// 	await context.SetLineCapAsync(LineCap.Round);
		// 	await context.BeginPathAsync();
		// 	Starting location of the snake/line (tail)
		// 	await context.MoveToAsync(50, 50);
		// 	Ending location of the snake/line (head)
		// 	await context.LineToAsync(100, 50);
		// 	await context.StrokeAsync();
		// }

		// foreach (Powerup p in TheWorld.powerups.Values) Bug
		// {
		// 	smaller yellow circle for powerups
		// 	await context.SetLineWidthAsync(5);
		// 	await context.SetStrokeStyleAsync($"rgb( 255, 255, 0 )");
		// 	await context.BeginPathAsync();
		// 	await context.ArcAsync(p.loc.x, p.loc.y, 3, 0, 2 * Math.PI);
		// 	await context.StrokeAsync();
		// }

		// Might not need the for-each loop because I dont need to make the walls several times.
		// foreach (ObstacleWall wall in TheWorld.walls.Values)
		// {

		// 	Have two walls: one vertical and one horizontal

		foreach (ObstacleWall wall in TheWorld.walls.Values) 
		{
			// for vertical walls the x points will be the same

			if (wall.p1.x == wall.p2.x) 
			{
				for (int i = wall.p1.y; i < wall.p2.y; i+= 50)
				{
					await context.DrawImageAsync(wallImage, wall.p1.x, wall.p1.y + i, 50, 50);
				}
			}

			// for horizional walls the y points will be the same

			if (wall.p1.y == wall.p2.y)
			{
				for (int i = wall.p1.x; i < wall.p2.x; i+= 50) 
				{
					await context.DrawImageAsync(wallImage, wall.p1.x + i, wall.p1.y, 50, 50);
				}
			}
		}

		// 	Draw walls surrounding the world
		// 	Vertical Left
		// 	await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
		// 	Vertical Right
		// 	await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
		// 	Horizontal Top
		// 	await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
		// 	Horizontal Bottom
		// 	await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);

		// 	Draw ___ (6? 10?) randomly placed and rotated walls in the world
		// 	for (int i = 0; i < 3; i++)
		// 	{
		// 		Draw one vertical wall in a random spot
		// 		await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
		// 		Draw one horizontal wall in a random spot
		// 		await context.DrawImageAsync(backgroundImage, -TheWorld.Width / 2, -TheWorld.Height / 2, TheWorld.Width, TheWorld.Height);
		// 	}

		// 	figure out how to draw one wall

		// }

		// finish batch drawing
		// await context.EndBatchAsync();

		StateHasChanged();
	}

	/// <summary>
	/// Handler for the connect button
	/// Attempt to connect to the server, then start an asynchronous loop
	/// to receive and display messages.
	/// Called only when you click the connect button.
	/// </summary>
	private void ConnectToServer()
	{
		new Thread(() => network.HandleConnect(UserName)).Start();
	}

	/// <summary>
	///     Disconnects the user from the server.
	/// </summary>
	private void DisconnectFromServer()
	{
		network.DisconnectServer();
	}

	/// <summary>
	///     When the user presses a specific key on the keyboard, the snake on the screen
	///     asks the server to move.
	/// </summary>
	/// <param name="key"></param>
	[JSInvokable]
	public void HandleKeyPress(string key)
	{
		if (network.IsConnected)
		{
			key = key.ToLower();
			// TODO: Once the client is connected and the handshake is complete,
			//       invoke some controller method to send the appropriate command to the server
			if (key.Equals("w")) /*Keep track of the axis*/
			{
				network.moveUP();
			}
			else if (key.Equals("a")) /*Keep track of the axis*/
			{
				network.moveLEFT();
			}
			else if (key.Equals("s")) /*Keep track of the axis*/
			{
				network.moveRIGHT();
			}
			else if (key.Equals("d")) /*Keep track of the axis*/
			{
				network.moveDOWN();
			}

			// TODO: Remove this, which is just here to show you what the 'key' string is for whatever key you pressed
			Debug.WriteLine("key pressed: " + key);
		}
	}
}

